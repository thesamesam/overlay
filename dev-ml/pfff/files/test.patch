From 0e10bc3a4ccd507d39a247fffa55ace86b0821de Mon Sep 17 00:00:00 2001
From: Yoann Padioleau <pad@returntocorp.com>
Date: Tue, 16 Mar 2021 16:22:37 +0100
Subject: [PATCH] Update ppx_profiling to ppxlib (#403)

see https://github.com/ocaml-ppx/ppxlib/issues/168

test plan:
make
---
 lang_python/parsing/Parse_python.ml |   5 +-
 lang_python/parsing/dune            |   2 +-
 pfff.opam                           |   1 +
 ppx/dune                            |   6 +-
 ppx/ppx_profiling.ml                | 170 +++++++++++++---------------
 5 files changed, 89 insertions(+), 95 deletions(-)

diff --git a/lang_python/parsing/Parse_python.ml b/lang_python/parsing/Parse_python.ml
index 347f11f31..60ff9799a 100644
--- a/lang_python/parsing/Parse_python.ml
+++ b/lang_python/parsing/Parse_python.ml
@@ -52,7 +52,7 @@ let error_msg_tok tok =
 (*****************************************************************************)
 
 (*s: function [[Parse_python.tokens2]] *)
-let tokens2 parsing_mode file =
+let tokens parsing_mode file =
   let state = Lexer.create () in
   let python2 = parsing_mode = Python2 in
   let token lexbuf =
@@ -91,10 +91,9 @@ let tokens2 parsing_mode file =
   Parse_info.tokenize_all_and_adjust_pos ~unicode_hack:true
     file token TH.visitor_info_of_tok TH.is_eof
 (*e: function [[Parse_python.tokens2]] *)
+[@@profiling]
 
 (*s: function [[Parse_python.tokens]] *)
-let tokens a b =
-  Common.profile_code "Parse_python.tokens" (fun () -> tokens2 a b)
 (*e: function [[Parse_python.tokens]] *)
 
 (*****************************************************************************)
diff --git a/lang_python/parsing/dune b/lang_python/parsing/dune
index 1c9c7a7f8..ba23d006c 100644
--- a/lang_python/parsing/dune
+++ b/lang_python/parsing/dune
@@ -7,7 +7,7 @@
    commons commons_core
    pfff-config pfff-h_program-lang
  )
- (preprocess (pps ppx_deriving.show))
+ (preprocess (pps ppx_deriving.show ppx_profiling))
 )
 (ocamllex Lexer_python)
 (menhir (modules Parser_python)
diff --git a/pfff.opam b/pfff.opam
index 01fdebff6..bf4aaa018 100644
--- a/pfff.opam
+++ b/pfff.opam
@@ -38,6 +38,7 @@ depends: [
   "grain_dypgen"
   "ppx_deriving"
   "ppx_hash"
+  "ppxlib"
   "uutf"
   "uucp"
   "ounit2"
diff --git a/ppx/dune b/ppx/dune
index 675753581..0850f075f 100644
--- a/ppx/dune
+++ b/ppx/dune
@@ -2,5 +2,7 @@
  (public_name ppx_profiling)
  (kind ppx_deriver)
  (libraries
-   str unix
-   commons ocaml-migrate-parsetree))
+   commons
+   ppxlib
+ )
+)
diff --git a/ppx/ppx_profiling.ml b/ppx/ppx_profiling.ml
index eb1e43d46..08fbd4453 100644
--- a/ppx/ppx_profiling.ml
+++ b/ppx/ppx_profiling.ml
@@ -1,6 +1,6 @@
 (* Yoann Padioleau
  *
- * Copyright (C) 2020 r2c
+ * Copyright (C) 2020, 2021 r2c
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public License
@@ -12,26 +12,8 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the file
  * license.txt for more details.
 *)
-[@@@warning "-42"]
-
-open Migrate_parsetree
-open Ast_408
-let ocaml_version = Versions.ocaml_408
-
-open Ast_mapper
+open Ppxlib
 open Ast_helper
-open Asttypes
-open Parsetree
-open Longident
-open Location
-
-(* update:
- * https://tarides.com/blog/2019-05-09-an-introduction-to-ocaml-ppx-ecosystem
- *
- * alt:
- *  - my request for [@@deriving like for function definitions
- *    https://github.com/ocaml-ppx/ppxlib/issues/168#issuecomment-688748491
-*)
 
 (*****************************************************************************)
 (* Prelude *)
@@ -66,14 +48,24 @@ open Location
  *   $ ocamlc -dsource _build/default/src/foo.pp.ml
  * to display the preprocessed code of src/foo.ml
  *
- * doc:
- *  - original tutorial blog post for ppx_getenv:
- *  https://whitequark.org/blog/2014/04/16/a-guide-to-extension-points-in-ocaml/
+ * history and documentation:
+ *  - first version based on original tutorial blog post for ppx_getenv:
+ *    https://whitequark.org/blog/2014/04/16/a-guide-to-extension-points-in-ocaml/
+ *  - use ocaml-migrate-parsetree ppx driver, so portable ppx rewriter
+ *    http://ocamllabs.io/projects/2017/02/15/ocaml-migrate-parsetree.html
  *  - update of ppx_getenv using the latest ppxlib
- *  http://rgrinberg.com/posts/extension-points-3-years-later/
- *  (in my opinion it's not worth the complexity)
- *  - update to use ocaml-migrate-parsetree so portable ppx rewriter
- *   http://ocamllabs.io/projects/2017/02/15/ocaml-migrate-parsetree.html
+ *    http://rgrinberg.com/posts/extension-points-3-years-later/
+ *    but in my opinion it was not worth the complexity
+ *  - deprecation of ocaml-migrate-parsetree ppx driver, so had to
+ *    switch to ppxlib. Read some documentation like
+ *    https://tarides.com/blog/2019-05-09-an-introduction-to-ocaml-ppx-ecosystem
+ *    or the ppxlib manual, but they provide helpers for [@@deriving] like
+ *    extensions that can not be apply to function definitions
+ *    (see my issues for [@@deriving like for function definitions
+ *    https://github.com/ocaml-ppx/ppxlib/issues/168#issuecomment-688748491).
+ *    I followed nathan advice in the issue above and implemented
+ *    ppx_profiling via Driver.register_transformation, which was
+ *    pretty close to what I had before with ocaml-migrate-parsetree.
 *)
 
 (*****************************************************************************)
@@ -103,74 +95,74 @@ let rec mk_args loc n =
 let module_name_of_filename s =
   let (_d, b, _e) = Common2.dbe_of_filename s in
   String.capitalize_ascii b
-
 (*****************************************************************************)
 (* Mapper *)
 (*****************************************************************************)
 
-let mapper _config _cookies =
-  { default_mapper with
-    structure = fun mapper xs ->
-      xs |> List.map (fun item ->
-        match item with
-        (* let <fname> = ... [@@profiling <args_opt> *)
-        | { pstr_desc =
-              Pstr_value (_,
-                          [{pvb_pat = {ppat_desc = Ppat_var {txt = fname; _}; _};
-                            pvb_expr = body;
-                            pvb_attributes = [
-                              { attr_name = {txt = "profiling"; loc};
-                                attr_payload = PStr args; attr_loc = _;
-                              }
-                            ];
-                            pvb_loc = _;
-                           }
-                          ])
-          ; _} ->
-            let nbparams = nb_parameters body in
-            (* you can change the action name by specifying an explicit name
-             * with [@@profiling "<explicit_name>"]
-            *)
-            let action_name =
-              match args with
-              | [] ->
-                  let pos = loc.Location.loc_start in
-                  let file = pos.Lexing.pos_fname in
-                  let m = module_name_of_filename file in
-                  m ^ "." ^ fname
-              | [{pstr_desc =
-                    Pstr_eval
-                      ({pexp_desc = Pexp_constant (Pconst_string (name, None));_},
-                       _); _}] -> name
-              | _ ->
-                  raise (Location.Error (
-                    Location.error ~loc
-                      "@@profiling accepts nothing or a string"))
-            in
-            (* let <fname> a b = Common.profile_code <action_name> (fun () ->
-             *         <fname> a b)
-            *)
-            let item2 =
-              Str.value Nonrecursive [
-                Vb.mk (Pat.var {txt = fname; loc})
-                  (mk_params loc nbparams
-                     (Exp.apply
-                        (Exp.ident
-                           {txt = Ldot (Lident "Common", "profile_code" ); loc})
-                        [Nolabel, Exp.constant (Pconst_string (action_name, None));
-                         Nolabel, Exp.fun_ Nolabel None (Pat.any ())
-                           (Exp.apply (Exp.ident {txt = Lident fname; loc})
-                              (mk_args loc nbparams))
-                        ]))
-              ]
-            in
-            [ item; item2]
-        | x -> [default_mapper.structure_item mapper x]
-      ) |> List.concat
-  }
+(* TODO: use Ast_traverse to visit and map, so we do not transform
+ * only toplevel function definitions but also annotations on functions in
+ * nested modules.
+*)
+let impl xs =
+  xs |> List.map (fun item ->
+    match item with
+    (* let <fname> = ... [@@profiling <args_opt> *)
+    | { pstr_desc =
+          Pstr_value (_,
+                      [{pvb_pat = {ppat_desc = Ppat_var {txt = fname; _}; _};
+                        pvb_expr = body;
+                        pvb_attributes = [
+                          { attr_name = {txt = "profiling"; loc};
+                            attr_payload = PStr args; attr_loc = _;
+                          }
+                        ];
+                        pvb_loc = _;
+                       }
+                      ])
+      ; _} ->
+        let nbparams = nb_parameters body in
+        (* you can change the action name by specifying an explicit name
+         * with [@@profiling "<explicit_name>"]
+        *)
+        let action_name =
+          match args with
+          | [] ->
+              let pos = loc.Location.loc_start in
+              let file = pos.Lexing.pos_fname in
+              let m = module_name_of_filename file in
+              m ^ "." ^ fname
+          | [{pstr_desc =
+                Pstr_eval
+                  ({pexp_desc = Pexp_constant (Pconst_string (name, None));_},
+                   _); _}] -> name
+          | _ ->
+              Location.raise_errorf ~loc
+                "@@profiling accepts nothing or a string"
+        in
+        (* let <fname> a b = Common.profile_code <action_name> (fun () ->
+         *         <fname> a b)
+        *)
 
+        let item2 =
+          Str.value Nonrecursive [
+            Vb.mk (Pat.var {txt = fname; loc})
+              (mk_params loc nbparams
+                 (Exp.apply
+                    (Exp.ident
+                       {txt = Ldot (Lident "Common", "profile_code" ); loc})
+                    [Nolabel, Exp.constant (Pconst_string (action_name, None));
+                     Nolabel, Exp.fun_ Nolabel None (Pat.any ())
+                       (Exp.apply (Exp.ident {txt = Lident fname; loc})
+                          (mk_args loc nbparams))
+                    ]))
+          ]
+        in
+        [ item; item2]
+    | x -> [x]
+  ) |> List.concat
 (*****************************************************************************)
 (* Entry point *)
 (*****************************************************************************)
+
 let () =
-  Driver.register ~name:"ppx_profiling" ocaml_version mapper
+  Driver.register_transformation ~impl "ppx_profiling"
